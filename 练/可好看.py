# -*- coding:utf-8 -*-
"""
@author:李丹
@file:可好看.py
@time:2023/3/12 9:23
"""   
# a = 2022
# while True:
#     s = hex(a)[2:]
#     if ''.join(s).isalpha():
#         print(a)
#         break
#     a+=1
# def num(x,y,z):
#     return x*26*26+y*26+z
# def tt(x,y,z):
#     a=''
#     a+=chr(ord("A")+x-1)
#     a+=chr(ord('A')+y-1)
#     a+=chr(ord('A')+z-1)
#     return a
# n = 2022
# for i in range(1,27):
#     for j in range(1,27):
#         for k in range(1,27):
#             if num(i,j,k) == 2022:
#                 print(tt(i,j,k))
#                 exit()
# import datetime
# start = datetime.date(1900,1,1)
# end = datetime.date(9999,12,31)
# def num(n):
#     return sum([int(i) for i in str(n)])
# count = 0
# while start < end:
#     y, m, d = start.year, start.month, start.day
#     if num(y) == num(m)+num(d):
#         count += 1
#     start +=datetime.timedelta(days=1)
# print(count)
# num = [0,99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 ]
# count = 0
# for i in range(1,31):
#     for j in range(i+1,31):
#         if num[i]*num[j] >=2022:
#             count+=1
# print(count)
# w = int(input())
# n = int(input())
# print((w+n)%7)
# n = str(input())
# b = n.lower()
# if b == 'lanqiao' and b.isalpha():
#     print('yes')
# else:
#     print('no')
# S = []
# n = input()
# for i in n:
#     S.append(i)
# if len(S)==7:
#     if S[0] == "L" or S[0] == 'l' and S[1] =='A' or S[1]=='a' and S[2] =='N' or S[2] =='n' and S[3] == 'Q' or S[3] == 'q' and S[4] == 'I' or S[4] == 'i' and S[5] == 'A' or S[5] == 'a' and S[6] == 'O' or S[6] == 'o':
#         print('yes')
#     else:
#         print('no')
# else:
#     print('no')
import sys

sys.setrecursionlimit(1 << 31 - 1)

matrix = '''110010000011111110101001001001101010111011011011101001111110
010000000001010001101100000010010110001111100010101100011110
001011101000100011111111111010000010010101010111001000010100
101100001101011101101011011001000110111111010000000110110000
010101100100010000111000100111100110001110111101010011001011
010011011010011110111101111001001001010111110001101000100011
101001011000110100001101011000000110110110100100110111101011
101111000000101000111001100010110000100110001001000101011001
001110111010001011110000001111100001010101001110011010101110
001010101000110001011111001010111111100110000011011111101010
011111100011001110100101001011110011000101011000100111001011
011010001101011110011011111010111110010100101000110111010110
001110000111100100101110001011101010001100010111110111011011
111100001000001100010110101100111001001111100100110000001101
001110010000000111011110000011000010101000111000000110101101
100100011101011111001101001010011111110010111101000010000111
110010100110101100001101111101010011000110101100000110001010
110101101100001110000100010001001010100010110100100001000011
100100000100001101010101001101000101101000000101111110001010
101101011010101000111110110000110100000010011111111100110010
101111000100000100011000010001011111001010010001010110001010
001010001110101010000100010011101001010101101101010111100101
001111110000101100010111111100000100101010000001011101100001
101011110010000010010110000100001010011111100011011000110010
011110010100011101100101111101000001011100001011010001110011
000101000101000010010010110111000010101111001101100110011100
100011100110011111000110011001111100001110110111001001000111
111011000110001000110111011001011110010010010110101000011111
011110011110110110011011001011010000100100101010110000010011
010011110011100101010101111010001001001111101111101110011101'''

matrix = matrix.split('\n')  # 横坐标
print(matrix)
matrix = list(map(list,matrix))  # map函数返回一个迭代器  纵坐标
print(matrix)
n, m = len(matrix), len(matrix[0])
print(n,m)
f = [(-1, 0), (1, 0), (0, -1), (0, 1)] # 上下左右方向
#
#
def dfs(x, y):
    global cnt  # 在函数内部声明
    matrix[x][y] = '0'
    cnt += 1
    for fx, fy in f:
        nx, ny = x + fx, y + fy
        if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == '1':
            dfs(nx, ny)  # 进行深搜
#
#
ans = 0
for i in range(n):
    for j in range(m):
        if matrix[i][j] == '1':
            cnt = 0  # 求取连通分量
            dfs(i, j)
            ans = max(ans, cnt)  # 取最大连通分量
print(ans)
#
